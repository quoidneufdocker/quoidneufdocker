{"version":"https://jsonfeed.org/version/1.1","title":"Build on Quoi d'neuf Docker?","home_page_url":"https://hugo-geekblog.geekdocs.de/","feed_url":"https://hugo-geekblog.geekdocs.de/tags/build/feed.json","authors":[{"name":"Nicolas De Loof"}],"items":[{"title":"Docker buil 101","date_published":"2021-11-09T12:12:00+02:00","date_modified":"2021-11-09T14:47:59+01:00","id":"https://hugo-geekblog.geekdocs.de/posts/build_101/","url":"https://hugo-geekblog.geekdocs.de/posts/build_101/","content_html":"\u003cp\u003eComme beaucoup d\u0026rsquo;entre vous, j\u0026rsquo;ai pesté devant un \u003ccode\u003edocker build\u003c/code\u003e qui télécharge pour la 101ème fois les mêmes paquets \u003ccode\u003eapt install\u003c/code\u003e .\u003c/p\u003e\n\u003cp\u003ePlutôt que de continuer à subir, je vous propose une série d\u0026rsquo;articles de mieux comprendre \u003ccode\u003edocker build\u003c/code\u003e et d\u0026rsquo;explorer quelques pistes pour le rendre plus efficace.\u003c/p\u003e\n\u003cp\u003ePour ce premier article, nous allons commencer par les bases.\u003c/p\u003e\n\u003cdiv class=\"gblog-post__anchorwrap\"\u003e\n    \u003ch2 id=\"back-to-basics\"\u003e\n        back to basics\n        \u003ca data-clipboard-text=\"https://hugo-geekblog.geekdocs.de/posts/build_101/#back-to-basics\" class=\"gblog-post__anchor gblog-post__anchor--right clip\" aria-label=\"Anchor back to basics\" href=\"#back-to-basics\"\u003e\n            \u003csvg class=\"icon gblog_link\"\u003e\u003cuse xlink:href=\"#gblog_link\"\u003e\u003c/use\u003e\u003c/svg\u003e\n        \u003c/a\u003e\n    \u003c/h2\u003e\n\u003c/div\u003e\u003cp\u003eUn image Docker est une succession de \u0026ldquo;couches\u0026rdquo; (\u003cem\u003elayers\u003c/em\u003e) chacune représentant des modifications apportées au système de fichier. Chaque ligne du \u003ccode\u003eDockerfile\u003c/code\u003e indique une directive qui va construire une nouvelle couche, qui va venir s\u0026rsquo;empiler sur la précédente.\u003c/p\u003e\n\u003cp\u003eUn postulat de Docker, c\u0026rsquo;est qu\u0026rsquo;une commande passée sur un état bien défini du système de fichier en cours de construction donnera toujours le même résultat. C\u0026rsquo;est ce qui lui permet de ne pas rejouer l\u0026rsquo;intégralité des commandes à chaque \u003ccode\u003edocker build\u003c/code\u003e, mais juste ce qui a été modifié.\u003c/p\u003e\n\u003cp\u003eVoilà; maintenant, tout ça ne vient pas sans quelques impacts\u0026hellip;\u003c/p\u003e\n\u003cdiv class=\"gblog-post__anchorwrap\"\u003e\n    \u003ch2 id=\"apt-quoi\"\u003e\n        apt-quoi?\n        \u003ca data-clipboard-text=\"https://hugo-geekblog.geekdocs.de/posts/build_101/#apt-quoi\" class=\"gblog-post__anchor gblog-post__anchor--right clip\" aria-label=\"Anchor apt-quoi?\" href=\"#apt-quoi\"\u003e\n            \u003csvg class=\"icon gblog_link\"\u003e\u003cuse xlink:href=\"#gblog_link\"\u003e\u003c/use\u003e\u003c/svg\u003e\n        \u003c/a\u003e\n    \u003c/h2\u003e\n\u003c/div\u003e\u003cp\u003eLes premières commandes d\u0026rsquo;un \u003ccode\u003eDockerfile\u003c/code\u003e sont généralement du type:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eFROM ubuntu\nRUN apt update \u0026amp;\u0026amp; apt install machin bidule chose\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIl est rarissime de tomber sur un \u003ccode\u003eDockerfile\u003c/code\u003e dans lequel les dépendances système incluent une version exacte du paquet à installer. C\u0026rsquo;est bien et pas bien à la fois\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eSi on reconstruit l\u0026rsquo;image depuis un environnemnt tout neuf, on aura les dépendances système à jour sans devoir courrir après les derniers numéros de version et toucher au Dockerfile.\u003c/li\u003e\n\u003cli\u003eSi on a déjà cette commande en cache, on restera sur des dépendances devenues obsolètes\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIl va donc faloir trouver un compromis \u0026hellip; je suggère de faire un \u003ccode\u003edocker build --no-cache\u003c/code\u003e de temps en temps, genre chaque Lundi pendant la pause déjeuner, et je vous laisse le soin de construire un joli workflow de mise à jour sur cette base :P\u003c/p\u003e\n\u003cp\u003eA titre personnel, je trouverai plus \u0026ldquo;propre\u0026rdquo; de mettre des versions aux dépendances système, et d\u0026rsquo;avoir un outil de type \u003cem\u003evulnerability scanner\u003c/em\u003e qui m\u0026rsquo;informe qu\u0026rsquo;un paquet plus récent existe, ou plutôt qui me fait une Pull-Request en mode dependabot pour rafraîchir mon Dockerfile\u0026hellip; bref\u003c/p\u003e\n\u003cdiv class=\"gblog-post__anchorwrap\"\u003e\n    \u003ch2 id=\"tes-là-où-tes-pas-là\"\u003e\n        t\u0026rsquo;es là où t\u0026rsquo;es pas là?\n        \u003ca data-clipboard-text=\"https://hugo-geekblog.geekdocs.de/posts/build_101/#tes-là-où-tes-pas-là\" class=\"gblog-post__anchor gblog-post__anchor--right clip\" aria-label=\"Anchor t\u0026rsquo;es là où t\u0026rsquo;es pas là?\" href=\"#tes-l%c3%a0-o%c3%b9-tes-pas-l%c3%a0\"\u003e\n            \u003csvg class=\"icon gblog_link\"\u003e\u003cuse xlink:href=\"#gblog_link\"\u003e\u003c/use\u003e\u003c/svg\u003e\n        \u003c/a\u003e\n    \u003c/h2\u003e\n\u003c/div\u003e\u003cp\u003eRien à voir avec \u003ca class=\"gblog-markdown__link\" href=\"https://www.youtube.com/watch?v=4LyVjNwLabk\"\u003eles Tuches\u003c/a\u003e. Du fait de l\u0026rsquo;empilement des couches, une \u003cem\u003esuppression\u003c/em\u003e n\u0026rsquo;en est pas réellement une. Un fichier supprimé est bien absent du système de fichier final, mais il existe dans les couches intermédiaires et alourdit l\u0026rsquo;image.\u003c/p\u003e\n\u003cp\u003eRésultat, vous verrez un peu partout ce genre de chose:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eRUN apt-get update \\\n  \u0026amp;\u0026amp; apt-get install -y --no-install-recommends machin \n  \u0026amp;\u0026amp; apt-get clean \\\n  \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/*\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCe mix de commande installe un paquet système, après avoir mis à jour les métadonnées, puis fait le ménage des divers caches pour ne pas embarquer de fichiers inutiles dans la couche en cours de construction. C\u0026rsquo;est bien optimisé tout ça, mais bye bye la lisibilibté!\u003c/p\u003e\n\u003cp\u003eLa \u003ca class=\"gblog-markdown__link\" href=\"https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#here-documents\"\u003esyntaxe proposée\u003c/a\u003e (à titre experimental) par BuildKit sous forme de \u0026ldquo;\u003ca class=\"gblog-markdown__link\" href=\"https://fr.wikipedia.org/wiki/Here_document\"\u003ehere-document\u003c/a\u003e\u0026rdquo; nous économise les \u003ccode\u003e\\\u003c/code\u003e et autres \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e mais bon, le problème reste assez présent:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# syntax = docker/dockerfile:1.3-labs\n...\nRUN \u0026lt;\u0026lt;eof\n    apt-get update\n    apt-get install -y --no-install-recommends machin \n    apt-get clean \n    rm -rf /var/lib/apt/lists/*\neof    \n\u003c/code\u003e\u003c/pre\u003e\u003cdiv class=\"gblog-post__anchorwrap\"\u003e\n    \u003ch2 id=\"cache-invalidation\"\u003e\n        cache invalidation\n        \u003ca data-clipboard-text=\"https://hugo-geekblog.geekdocs.de/posts/build_101/#cache-invalidation\" class=\"gblog-post__anchor gblog-post__anchor--right clip\" aria-label=\"Anchor cache invalidation\" href=\"#cache-invalidation\"\u003e\n            \u003csvg class=\"icon gblog_link\"\u003e\u003cuse xlink:href=\"#gblog_link\"\u003e\u003c/use\u003e\u003c/svg\u003e\n        \u003c/a\u003e\n    \u003c/h2\u003e\n\u003c/div\u003e\u003cp\u003eL\u0026rsquo;invalidation des caches est l\u0026rsquo;un des problèmes les plus complexe de notre industrie, avec le nommage des variables.\u003c/p\u003e\n\u003cp\u003eDans le cas d\u0026rsquo;un \u003ccode\u003eDockerfile\u003c/code\u003e, \u003ccode\u003edocker build\u003c/code\u003e doit savoir quel layer reconstruire et lequel peut être utilisé tel quel depuis le cache. Là où ça devient compliqué c\u0026rsquo;est quand il doit ajouter du contentu externe à l\u0026rsquo;image.\u003c/p\u003e\n\u003cp\u003eHistoriquement nous avions la directive \u003ccode\u003eADD\u003c/code\u003e. Bon, oubliez là tout de suite. Elle permet de télécharger un truc pour mettre dans l\u0026rsquo;image, mais du coup, comment savoir s\u0026rsquo;il faut re-télécharger? Faudrait il respected les headers HTTP \u0026ldquo;Last-Modified\u0026rdquo;? Amusez vous à lire dans les issues Docker les kilomètre de débats sur ce sujet.\u003c/p\u003e\n\u003cp\u003eLa commande \u003ccode\u003eCOPY\u003c/code\u003e permet d\u0026rsquo;inclure un fichier local dans l\u0026rsquo;image. Ici c\u0026rsquo;est plus simple, si le fichier est le même, le résultat sera (devrait être?) le même, et le cache n\u0026rsquo;est pas invalidé. S\u0026rsquo;il est modifié, plus rien n\u0026rsquo;est sur, le cache est invalide et toutes les commandes à suivre doivent être rejouées.\u003c/p\u003e\n\u003cp\u003eEt c\u0026rsquo;est pour ça qu\u0026rsquo;on évite ce genre de choses:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eFROM maven\nCOPY . /work\nRUN mvn package\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEn faisant ça, le moindre changement d\u0026rsquo;un fichier dans le projet va relancer un build maven complet, avec les 200Mo de téléchargements que cela implique.\u003cbr\u003e\nOn vous recommandra donc des choses nettement plus élaborées, comme:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCOPY pom.xml /work\nRUN mvn dependency:go-offline\nCOPY . /work\nRUN mvn package\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCette astuce permet de lier l\u0026rsquo;étape de téléchargement des dépendances au seul fichier de description du projet (\u003ccode\u003epom.xml\u003c/code\u003e, \u003ccode\u003epackage.json\u003c/code\u003e, \u003ccode\u003eGemfile\u003c/code\u003e, etc). Tant que celui-ci n\u0026rsquo;est pas modifié, seul le second \u003ccode\u003eCOPY\u003c/code\u003e va invalider le cache.\u003c/p\u003e\n\u003cp\u003eJe crois sincèrement que c\u0026rsquo;est ce qui a propulsé la commande Maven \u003ccode\u003edependency:go-offline\u003c/code\u003e bien au delà de son cas d\u0026rsquo;usage initial qui était \u0026ldquo;je vais bosser dans le TGV\u0026rdquo; à une époque ou le Wifi à bord tennait de la science fiction.\u003c/p\u003e\n\u003cdiv class=\"gblog-post__anchorwrap\"\u003e\n    \u003ch2 id=\"to-be-continued\"\u003e\n        to be continued\u0026hellip;\n        \u003ca data-clipboard-text=\"https://hugo-geekblog.geekdocs.de/posts/build_101/#to-be-continued\" class=\"gblog-post__anchor gblog-post__anchor--right clip\" aria-label=\"Anchor to be continued\u0026hellip;\" href=\"#to-be-continued\"\u003e\n            \u003csvg class=\"icon gblog_link\"\u003e\u003cuse xlink:href=\"#gblog_link\"\u003e\u003c/use\u003e\u003c/svg\u003e\n        \u003c/a\u003e\n    \u003c/h2\u003e\n\u003c/div\u003e\u003cp\u003eOn va en rester là pour ce premier article, il reste beaucoup à dire, mais on va prendre le temps de s\u0026rsquo;attaquer a chaque sujet séparément.\u003cbr\u003e\nA+\u003c/p\u003e\n"}]}